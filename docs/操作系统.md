## 操作系统概念

### 操作系统的运行机制

- 预备知识：程序是如何运行的？
  - c语言代码->机器指令（中间的过程编译汇编链接装载）
  - 程序的运行过程其实就是cpu执行一条条的机器指令的过程
  - “指令”就是指处理器能识别、执行的最基本命令
  - 要注意区分交互式命令接口与指令
  - 内核（kernel）程序vs应用程序
    - 普通程序员写的程序就是“应用程序”
    - 开发操作系统的就是写的“内核程序”

- 两种指令

  cpu在设计支出划分了特权指令和非特权指令，执行一条指令前就能判断出其类型

  - 特权指令
  - 非特权指令

- 两种处理器状态

  cpu中有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示“内核态”，0表示“用户态”

  别名：内核态=核心态=管态；用户态=目态

  - 核心态
  - 用户态

- 两种程序

  - 内核程序
  - 应用程序

- 内核

  - 内核是操作系统中最重要最核心的部分
  - 有很多内核程序组成操作系统内核

- 如何变态？

  - 内核态->用户态——一条修改PSW的特权指令
  - 用户态->内核态——由中断引起，硬件自动完成

### 中断和异常

- 中断的作用

  - cpu上会运行两种程序，一种是操作系统内核程序，一种是应用程序

  - 在合适的情况下，操作系统内核会把cpu的使用权主动让给应用程序

  - “中断”是让操作系统内核夺回cpu使用权的唯一途径

  - 关联并发

- 中断的类型

  大多数的教材中。“中断”特指狭义的中断，即外中断。而内中断一般称为“异常”

  - 内中断（也称“异常”、“例外”）

    - 终止——试图在用户态下执行特权指令
    - 故障——执行除法指令时发现除数为0
    - 陷阱、陷入(trap)——有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令，该指令会引发一个内部中断信号

    与当前执行的指令有关，中断信号来源于cpu内部

  - 外中断（也称“中断”）

    - 时钟中断——由时钟部件发来的中断信号
    - I/O中断请求——由输入/输出设备发来的中断信号
    
    与当前执行的指令无关，中断信号来源于cpu外部

- 中断机制的基本原理

  不同的中断信号，需要用不同的中断处理程序来处理。当cpu检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置

### 系统调用

- 什么是系统调用

  “系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务

- 系统调用与库函数的区别

  | 普通应用程序 | 可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及                       |
  | ------------ | -------------------------------------------------------------------------------------------- |
  | 编程语言     | 向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便 |
  | 操作系统     | 向上提供系统调用，使得上层程序能请求内核的服务                                               |
  | 裸机         |                                                                                              |

  不涉及系统调用的库函数：如：“取绝对值”的函数

  涉及系统调用的库函数：如：“创建一个新文件”的函数

- 小例子：为什么调用是必须的？

  word和wps打印文档，如果并发进行就混杂了

  解决方法：由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用”，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理

- 什么功能要用系统调用实现？

  应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作

  - 按功能分类
    - 设备管理——完成设备的 请求/释放/启动 等功能
    - 文件管理——完成文件的 读/写/创建/删除 等功能
    - 进程控制——完成进程的 创建/撤销/阻塞/唤醒 等功能
    - 进程通信——完成进程之间的 消息传递/信号传递 等功能
    - 内存管理——完成内存的 分配/回收 等功能

- 系统调用的过程

  - 传参
  - 陷入指令/trap/访管
  - 由操作系统内核程序处理系统调用请求
  - 返回应用程序

  陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使cpu进入核心态

  发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行

### 操作系统的体系结构

|                     用户                      |
| :-------------------------------------------: |
|                   应用程序                    |
|              非内核功能（如GUI）              |
|     进程管理、存储器管理、设备管理等功能      |
| 时钟管理 中断处理 原语（设备驱动、cpu切换等） |
|                     裸机                      |

- 利用时钟中断实现计时功能

- 原语是一种特殊的程序，具有原子性，也就是说，这段程序的运行必须一气呵成，不可被“中断”

- ubuntu、centos的开发团队，其主要工作室实现非内核功能，而内核都是用了linux内核
- 典型的内核操作系统
  - 大内核：Linux、UNIX
  - 微内核：Window NT
- 变态的过程是有成本的，频繁的变态会降低系统性能

- 大内核（又名：宏内核/单内核）两次变态

  - 内核态
    - 进程管理
    - 存储管理
    - 时钟管理、中断管理、原语
  - 优点：高性能
  - 缺点：内核代码庞大，结构混乱，难以维护

- 微内核 六次变态

  - 用户态
    - 进程管理
    - 存储管理
    - 设备管理

  - 内核态
    - 时钟管理、中断管理、原语
  - 优点：内核功能少，结构清晰，方便维护
  - 缺点：需要频繁地在核心态和用户态之间切换，性能低

- 分层结构

  - 最底层是硬件，最高层是用户接口，每层可调用更低一层
  - 优点
    - 便于调试和验证，自底向上逐层调试验证
    - 易扩充和易维护，各层之间调用接口清晰固定
  - 缺点
    - 仅可调用相邻低层，难以合理定义各层的边界
    - 效率低，不可跨层调用，系统调用执行时间长

- 模块化

  -  将内核划分为多个模块，各模块之间相互协作

    内核=主模块+可加载内核模块

    主模块只负责核心功能，如进程调度、内存管理

    可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核

  - 优点

    - 模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发
    - 支持动态加载新的内核模块（如：安装设备驱动程序、安装新的文件系统模块到内核），增强OS适应性
    - 任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高

  - 缺点

    - 模块间的接口定义未必合理、实用
    - 模块间相互依赖、更难调试和验证

- 外核

  - 内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全
  - 优点
    - 外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以更灵活的使用硬件资源
    - 减少了虚拟硬件资源的“映射层”，提升效率
  - 缺点
    - 降低了系统的一致性
    - 使系统变得更复杂

### 操作系统引导

- cpu从一个特定的主存地址开始，取指令，执行ROM中的引导程序（先进行硬件自检，再开机）
- 将磁盘的第一块——主引导记录 读入内存，执行磁盘引导程序，扫描分区表
- 从活动分区（又称主分区，即安装了操作系统的分区）读入分区引导记录，执行其中的程序
- 从根目录下找到完整的操作系统初始化程序（即 启动器管理器）并执行，完成“开机”的一系列动作

### 虚拟机

- 使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器（Virtual Machine,VM），每个虚拟机器都可以独立运行一个操作系统

- 虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor/Hypervisor

  - 第一类：直接运行在硬件上
  - 第二类：运行在宿主操作系统上（vmware）

- 两类的对比

  |                    | 第一类VMM                                                                                             | 第二类VMM                                                                                                      |
  | ------------------ | ----------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
  | 对物理资源的控制权 | 直接运行在硬件之上，能直接控制和分配物理资源                                                          | 运行在host os之上，依赖于host os为其分配物理资源                                                               |
  | 资源分配方式       | 在安装guest os时，VMM要在原本的硬盘上自行分配存储空间，类似于“外核”的分配方式，分配未经抽象的物理硬件 | guest os拥有自己的虚拟磁盘，改判实际上是host os文件系统中的一个大文件。guest os分配到的内存是虚拟内存          |
  | 性能               | 性能更好                                                                                              | 性能更差，需要host os作为“中介”                                                                                |
  | 可支持的虚拟机数量 | 更多，不需要和host os竞争资源，相同的硬件资源可以支持更多的虚拟机                                     | 更少，host os本身需要使用物理资源，host os上运行其他进程也需要物理资源                                         |
  | 虚拟机的可迁移性   | 更差                                                                                                  | 更好，只需导出虚拟机镜像文件即可迁移到另一台host os上，商业化应用更广泛                                        |
  | 运行模式           | 第一类VMM运行在最高特权级（Ring 0），可以执行最高特权的指令                                           | 第二类VMM部分运行在用户态、部分运行在内核态。guest os发出的系统调用会被VMM截获，并转化为VMM对host os的系统调用 |

## 进程管理

### 进程的概念、组成、特征

- 概念——理解“进程”和“程序”的区别

  - 程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合
  - 进程：是动态的，是程序的一次执行过程

- 组成——一个进程由哪些部分组成

  - PCB

    以下信息都被保存在一个数据结构 PCB 中，即进程控制块

    操作系统要记录PID、进程用户所属用户ID（UID）

    还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）

    还要记录进程的运行情况（如：cpu使用时间、磁盘使用情况、网络流量使用情况等）

    - 进程描述信息
      - 进程标识符PID
      - 用户标识符UID
    - 进程控制和管理信息
      - cpu、磁盘、网络流量使用情况统计···
      - 进程当前状态：就绪态/阻塞态/运行态···
    - 资源分配清单
      - 正在使用哪些文件
      - 正在使用哪些哪些内存区域
      - 正在使用哪些I/O设备
    - 处理器相关信息
      - 如PSW、PC等等各种寄存器的值（用于实现进程切换）

  - 程序段——程序的代码（指令序列）

  - 数据段——运行过程中产生的各种数据（如：程序中定义的变量）

- 特征——进程有哪些重要的特征

### 进程的状态与转换

- 状态

  - 运行状态——占有CPU并在CPU上运行

    - 当cpu空闲时，操作系统就会选择一个就绪进程，让它上处理机运行

        如果一个进程此时在cpu上运行，那么这个进程处于“运行态”

  - 就绪状态——已经具备运行条件，但由于没有空闲CPU，而暂时不能运行

    - 当进程创建完成后，便进入“就绪态”，处于就绪态的进程已经具备运行条件，但由于没有空闲cpu，就暂时不能运行

  - 阻塞状态——因等待某一事件而暂时不能运行

    - 在进程运行的过程中，可能会请求等待某个事件的发生（如等待某种系统资源的分配，或者等待其他进程的响应）。

      在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下cpu，并让他进入“阻塞态”

      当cpu空闲时间，又会选择另一个“就绪态” 进程上cpu运行

  - 创建状态——进程正在被创建，操作系统为进程分配资源、初始化PCB

    - 进程正在被创建时，他的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化PCB

  - 终止状态——进程正在从系统中撤销，操作系统会回收进程所拥有的资源、撤销PCB

    - 一个进程可以执行exit系统调用，请求操作系统终止改进成该进程。此时该进程会进入“终止态”，操作系统会让该进程下cpu，并回收内存空间等资源，最后还要回收该进程的PCB

- 状态间的转换

  - 创建态->就绪态

    系统完成创建进程的一系列工作

  - 就绪态->运行态

    进程被调度

  - 运行态->就绪态

    时间片到，或处理机被抢占

  - 运行态->阻塞态

    进程用“系统调用”的方式申请某种系统资源，或者请求等待某个事件的发生

  - 阻塞态->就绪态

    申请的资源被分配，或等待的事件发生

  - 运行态->终止态

    进程运行结束，或运行过程中遇到不可修复的错误

- 进程的组织方式（各个进程PCB的组织方式）

  - 链接方式
    - 执行指针
    - 就绪队列指针
    - 阻塞队列指针
  - 索引方式
    - 执行指针
    - 就绪表指针
    - 阻塞表指针



























