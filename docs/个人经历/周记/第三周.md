之前写的都不太好，应该加个周计划的内容然后看能完成多少，况且距离第二周的已经相隔了 40 天了，原因暂且不表

然后之前其实是有第三周的，也算学了点有用的东西，但都跟开发有关，就是学习了基础的 gcc g++ 还有 gdb 调试以及写 CMakeLists.txt 文件(注意大小写严格)

### 计划

依然是向着逆向方面学，之前把 16 位的 x86 汇编看完了，arm 汇编依旧没怎么看，arm 方面的我选择不专门去看，看到不会的在临时看，所以就是逆向工程权威指南这本书

再然后就是因为之前杨大哥有让我们搞过固件分析，当时太蠢了啥都不懂，现在有思路了，我先是看了下主流的路由器板子，就是认识下 cpu、闪存、内存、供电等。接下来就是看一些主流的固件系统。然后看了一篇使用 IDA 逆向程序的帖子，了解了一些用法之后，开始看《IDA Pro 权威指南》。还有这本《逆向工程权威指南》。

1. [ARM汇编基础](https://azeria-labs.com/writing-arm-assembly-part-1/)花费周一周二看完，看完了之后就能基本无障碍读《逆向工程权威指南》
2. 《IDA Pro 权威指南》周三周四看三章第一部分内容
3. 《逆向工程权威指南》周五周六看三章第一部分内容
4. 其余时间会去补操作系统的一些知识，然后在这期间写周报

然后我认为也得看一下小迪的课程，以我目前的水平在逆向方面做不了什么实质的东西

### 2024年9月9日

#### ARM 汇编

##### ARM 数据类型和寄存器

1. 与高级语言类似，ARM 支持对不同数据类型的操作。

   ```shell
   ldr = 加载字
   ldr h = 加载无符号半字
   ldr sh = 加载有符号半字
   ldr b = 加载无符号字节
   ldr sb = 加载有符号字节
   字 32 位 半字 16 位 字节 8 位
   str = 存储字
   str h = 存储无符号半字
   str sh = 存储有符号半字
   str b = 存储无符号字节
   str sb = 存储有符号字节
   ```

2. 字节顺序有所不同，x86 架构分大小端查看，ARM 架构在版本 3 之前是小端，之后是双端，这意味着它具有允许可切换字节序的设置。例如，在 ARMv6 上，指令是固定的小端，数据访问可以是小端或大端，由程序状态寄存器 (CPSR) 的第 9 位（E 位）控制。

3. 寄存器数量取决于 ARM 版本，根据 ARM 参考手册，共有 30 个通用 32 位寄存器。前 16 个寄存器可在用户级模式下访问，其他寄存器可在特权软件执行中使用。

   > [!warning]
   >
   > 以上所说的内容，基于 ARMv6-M 和 ARMv7-M 的处理器除外。

4. 16个通用寄存器其中的几个与 x86 有区别

   - **LR**（链接寄存器）保存函数调用的下一个内存地址，方便子程序返回。x86 中没有专门的用于函数调用的寄存器，只有 call ret 组合来实现这个功能，call 的时候就会把下一个地址压入栈。

   - **PC**（程序计数器）在 ARM 状态下，此大小始终为 4 个字节，在 THUMB 模式下，则为 2 个字节。执行分支指令时，PC 保存目标地址。在执行过程中，在 ARM 状态下，PC 存储当前指令的地址加 8（两个 ARM 指令），在 Thumb(v1) 状态下，PC 存储当前指令的地址加 4（两个 Thumb 指令）。这与 x86 不同，在 x86 中，PC 始终指向下一个要执行的指令。

   - **CPSR**（当前程序状态寄存器）类似于 x86 中的标志寄存器

     |     标志      | 描述                                                         |
     | :-----------: | ------------------------------------------------------------ |
     |  N(Negative)  | 如果指令的结果产生负数，则启用。                             |
     |    Z(Zero)    | 如果指令的结果产生零值，则启用。                             |
     |   C(Carry)    | 如果指令的结果产生了一个需要第33位才能完全表示的值，则启用。 |
     |  V(Overflow)  | 如果指令的结果产生了一个在32位补码中无法表示的值，则启用。   |
     | E(Endian-bit) | ARM可以操作于小端模式或大端模式。此位设置为0表示小端模式，或设置为1表示大端模式。 |
     | T(Thumb-bit)  | 如果处于Thumb状态，则此位被设置；如果处于ARM状态，则此位被禁用。 |
     | M(Mode-bits)  | 这些位指定当前的特权模式（用户模式USR、系统模式SVC等）。     |
     |  J(Jazelle)   | 第三执行状态，允许一些ARM处理器在硬件中执行Java字节码。      |

##### ARM 指令集

1. ARM 处理器有两种主要的运行状态 **ARM 和 THUMB**。这些状态与特权级别无关。这两个状态之间的主要区别在于指令集，ARM 状态下的指令始终为 32 位，而 Thumb 状态下的指令为 16 位（但可以是 32 位）。需要知道在哪些地方使用Thumb代替ARM。引入Thumb增强指令集之后，还需要了解到自己的设备支持的是哪一种，并进行相应的调整。

2. ARM 和 Thumb 之间的区别：

   - 条件执行：ARM 状态下的所有指令都支持条件执行。某些 ARM 处理器版本允许使用 IT 指令在 Thumb 中进行条件执行。条件执行可提高代码密度，因为它减少了要执行的指令数量并减少了昂贵的分支指令数量。
   - 32 位 ARM 和 Thumb 指令：32 位 Thumb 指令具有 .w 后缀。
   - 桶形移位器是 ARM 模式的另一个独特功能。它可用于将多条指令缩减为一条。例如，您无需使用两条指令进行乘法运算（将寄存器乘以 2，然后使用 MOV 将结果存储到另一个寄存器中），而是可以使用左移 mov R1, R0, R0, LSL#1

3. 切换处理器的执行状态以下两个条件必须满足:

   - 我们可以使用分支指令BX（分支和交换）或BLX（分支，链接和交换）并将目标寄存器的最低有效位设置为1。可以通过添加1的偏移来实现，如0x5530+ 1。这不会因为指令要么是2字节，要么是4字节对齐而产生对齐问题。因为处理器将忽略最低有效位。

   - 如果当前程序状态寄存器中的T位置1，处于Thumb模式。

4. 指令集

   | 指令 |    描述    |  指令   |       描述       |
   | :--: | :--------: | :-----: | :--------------: |
   | MOV  |  移动数据  |   EOR   |    位运算异或    |
   | MVN  | 移动并取反 |   LDR   |       加载       |
   | ADD  |    加法    |   STR   |       存储       |
   | SUB  |    减法    |   LDM   |     多重加载     |
   | MUL  |    乘法    |   STM   |     多重存储     |
   | LSL  |  逻辑左移  |  PUSH   |      压入栈      |
   | LSR  |  逻辑右移  |   POP   |    从栈中弹出    |
   | ASR  |  算术右移  |    B    |       跳转       |
   | ROR  |   右旋转   |   BL    |    分支并链接    |
   | CMP  |    比较    |   BX    |    分支并交换    |
   | AND  |  位运算与  |   BLX   | 分支并链接并交换 |
   | ORR  |  位运算或  | SWI/SVC |     系统调用     |

##### 内存指令：加载和存储

> [!tip]
>
> ARM 使用加载-存储模型进行内存访问，这意味着只有加载/存储（LDR 和 STR）指令才能访问内存。虽然在 x86 上，大多数指令都允许直接对内存中的数据进行操作，但在 ARM 上，数据必须先从内存移到寄存器中才能进行操作。这意味着在 ARM 上增加特定内存地址的 32 位值需要三种类型的指令（加载、增量和存储），首先将特定地址的值加载到寄存器中，在寄存器内增加它，然后将其从寄存器存储回内存。

1. 基本示例

   ```assembly
   LDR R2, [R0]	@ [R0] - origin address is the value found in R0.
   STR R2, [R1]    @ [R1] - destination address is the value found in R1.
   #LDR 用于从内存加载数据到寄存器。
   STR 用于将寄存器中的数据存储到内存中
   ```

   👆很经典代码块直接说清楚 LDR 和 STR 关系

   假设：

   - `R0` 中的值是 `0x1000`，内存地址 `0x1000` 的内容是 `42`。
   - `R1` 中的值是 `0x2000`。

   执行这两条指令后：

   - `LDR R2, [R0]` 将 `42` 加载到 `R2` 中。

   - `STR R2, [R1]` 将 `42` 存储到内存地址 `0x2000` 中。

























