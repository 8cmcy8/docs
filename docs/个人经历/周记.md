- 应 2024年7月5日 应要求，我在此开始记录学习历程，我个人也比较喜欢记录只是之前没有以日记的形式来记录，这次就试试吧

- 之前会的东西在博客其他文章都有所记叙，现在属于是扩大技能树了

- 起始于2024年7月7日——结束至？？？？？

- 至于为什么5日布置的任务今天才开始，纯属因为自己懒，昨天给自己放松一天（班级团建+学游泳），之前的一段日子里都在学汇编、操作系统以及计算机组成原理，不过汇编最多再几天就结束了，后面两个每天多少得学点，现在四大件唯一学完的就是数据结构了，计网我感觉学的有点不充分，但也没必要专门去学了，以后碰到不会的了再去专门看

---

### 第一周

#### 2024年7月7日 周日

1. ***汇编语言***

   看了三章的内容，记录新指令和注意的点

    1. 标志寄存器  PSW

        - abc 和 sbb 用于进行更大位数的运算

        - cmp 相当于减法，不保存值，比较大小

        - 六个条件转移指令，满足条件就 jmp

        - 串传送指令 movsb、movsw + 两个 df 设置指令 cld（正）、std（负）

          rep 次数由 cx 寄存器中的值决定

        - pushf 和 popf 将标志寄存器的值压栈

    2. 内中断
   
        - 8086 cpu 中断向量表存放位置 0000:03FF，最后 256 字节是空的
   
        - 中断处理程序编写 & iret 指令
   
          在栈中弹出 CS:IP 的值以及弹出寄存器的值
   
          1. 保存用到的寄存器
   
          2. 处理中断
   
          3. 恢复用到的寄存器
   
          4. 用 iret 指令返回
   
        - 中断特殊情况：ss 和 sp 最好是连续设置
	
    3. int 指令
   
        - 指令的格式为：int n n为中断类型码
        - Bios中断例程
        - DOS中断例程
	
2. ***CTF***

   一直以来都想入CTF的大门，但是今天算真正看 [Wiki](https://ctf-wiki.org/) ，了解了赛制还有方向什么的，最关键的是这个平台上提供了很多学习资源，可以补全自己的技能树

3. ***修改博客***

   之前的博客文件结构有些问题，重新配置了文件路径，并且美化了一下，不过要想真正的做到自己修改还是得学前端，抽空再说吧

#### 2024年7月8日 周一

1. ***汇编语言***
   
   - 端口
     - 在 PC 系统中，CPU 最多可以定位 64KB 个不同的端口，地址范围为 0~65535
     - 对端口读写不能使用 mov、push、pop 等内存读写指令，只能使用 in 和 out
   
       > [!WARNING]
       > 只能使用 ax 或 al 来存放从端口中读入的数据或要发送到端口中的数据。访问 8 位端口时使用 al，访问 16 位端口时用 ax。
   
     - CMOS RAM 芯片
   
        - 包含一个实时钟和128存储单元的 RAM 存储器
        - 靠电池供电，所以 RAM 中的信息不丢失
        - 内部时钟占用 0~0dh 单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时 BIOS 程序读取
        - CPU 通过该芯片内部 70h（地址端口）、71h（数据端口） 两个端口读写 CMOS RAM
   
     - shl 和 shr 指令
       
       如果移动位数大于 1 时，必须将移动位数放在 cl 中
       - shl 逻辑左移指令
       - shr 逻辑右移指令
   
2. ***修改博客***

  今天仔细看了下中文排版的规矩，有所启发，于是花费时间把将近四个月前写的东西重新排版了一下，当时对于 markdown 还不熟练。再然后就是修改一些小错误。之前 vitepress 的官方文档我也就看了我需要看的部分，今天也是把能看懂的都看了一遍，安装了别人做好的主题样式，并且使用了一些新的 markdown 拓展语法，跟之前的十分简陋相比，现在已经丰富很多了


#### 2024年7月9日 周二

今天汇编语言结束了

1. ***汇编语言***

   1. 外中断

      - CPU 通过端口和外部设备进行联系

        - 两种外中断

          - 可屏蔽中断

            IF=1，CPU 在执行完当前指令后响应中断，IF=0，则不响应可屏蔽中断

            - sti：设置 IF=1
          
            - cli：设置 IF=0
          
          - 不可屏蔽中断

   		> [!IMPORTANT] 请注意
   		>
   		> 不可屏蔽中断是 CPU 必须响应的外中断。
   		>
   		> 对于 8086CPU，不可屏蔽中断的中断类型码固定为 2。

   2. PC 机键盘处理

       - 输入

          扫描码被送入 60h 端口。按键再松开会产生扫描码。断码 = 通码 + 80h。

          - 通码：按键产生

          - 断码：松开产生

          - 引发 9 号中断：中断类型码为 9

          - 执行 9 号中断

            在 BIOS 键盘缓冲区中，一个输入用一个字单元存放，高位字节扫描码，低位字节字符码

            0040:17 单元存储键盘状态字节

       - 直接定址表
   
          - 开头讲了一种新的定义段的方式，更加简便

            ```assembly
            data segment
              a db 1,2,3,4,5,6,7,8
              b dw 0
            data ends
            ```

          - 空间换时间

   3. 使用 BIOS 进行键盘输入和磁盘读写
      - int 9 和 int 16h 是相互配合的
   
      - int 9 中断例程对键盘输入的处理
        - I/O 接口
        - 60h 端口
        - 数据缓冲寄存器
        - 内存-键盘缓冲区
      
      - int 16h 中断例程读取键盘缓冲区。以下给出 0 号功能：
   
        1. 检测键盘缓冲区中是否有数据
        2. 没有则继续做第 1 步
        3. 读取缓冲区第 1 个字单元中的键盘输入
        4. 将读取的扫描码送入 ah，ASCII 码送入 al
        5. 将已读取的键盘输入从缓冲区删除
   
      - 字符串的输入
        1. 字符的输入和删除——栈
        2. 输入回车后，字符串输入结束
        3. 在输入的同时需要显示这个字符串
        4. 程序的处理过程
           - 调用 int 16h 读取键盘输入
           - 如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行调用
           - 如果是退格键，从字符栈中弹出一个显示字符栈中的所有字符；继续执行调用
           - 如果是 Enter 键，向字符栈中压入0，返回
   
      - 应用 int 13h 中断例程对磁盘进行读写
   
        入口参数比较多，我就打算把这块作以了解，以后用到

2. ***博客修改***

   今天阅读官方文档添加了友情链接的功能，并且添加了几个链接，我感觉我有点蠢前前后后又搞了一个半小时。然后就是修改文章格式，我现在还在纠结要不要把周记专门分出来一栏，分成一周一周的，从第一周开始一个一个添加 md 文件。
